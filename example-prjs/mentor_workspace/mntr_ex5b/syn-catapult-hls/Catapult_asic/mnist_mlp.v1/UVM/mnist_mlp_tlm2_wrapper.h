// TLM2 Wrapper
#include <string>
#include <iomanip>
using std::string;
#include <systemc.h>
#include <tlm.h>
using namespace tlm;
#include <simple_target_socket.h>
using tlm_utils::simple_target_socket;
#include <simple_initiator_socket.h>
using tlm_utils::simple_initiator_socket;

// design headers
#include "../../../../mnist_mlp/firmware/mnist_mlp.h"
#include "../../../../mnist_mlp/firmware/weights/w2.h"
#include "../../../../mnist_mlp/firmware/weights/b2.h"
#include "../../../../mnist_mlp/firmware/weights/w4.h"
#include "../../../../mnist_mlp/firmware/weights/b4.h"
#include "../../../../mnist_mlp/firmware/weights/w6.h"
#include "../../../../mnist_mlp/firmware/weights/b6.h"

#include <ccs_gp_typeconv.h>



enum TargetReadyMode { NON_EMPTY_CHAN = 0, CHAN_AVAIL, AT_LEAST_ONE_CALLBACK, EVERY_TRANS, DONT_CARE };

class mnist_mlp_tlm2_wrapper : sc_module
{
public: // Public interfaces
  // Target sockets for receiving transactions
  simple_target_socket<mnist_mlp_tlm2_wrapper> input1_rsc_target; // defaults to tlm_gp
  // Initiator socket for sending out transactions
  simple_initiator_socket<mnist_mlp_tlm2_wrapper>   output1_rsc_initiator;
  simple_initiator_socket<mnist_mlp_tlm2_wrapper>   const_size_in_1_rsc_initiator;
  simple_initiator_socket<mnist_mlp_tlm2_wrapper>   const_size_out_1_rsc_initiator;

  // Constructor
  SC_HAS_PROCESS(mnist_mlp_tlm2_wrapper);
  mnist_mlp_tlm2_wrapper(const sc_module_name &nm)
    : sc_module(nm)
    , input1_rsc_target("input1_rsc_target")
    , output1_rsc_initiator("output1_rsc_initiator")
    , const_size_in_1_rsc_initiator("const_size_in_1_rsc_initiator")
    , const_size_out_1_rsc_initiator("const_size_out_1_rsc_initiator")
    , debug(0)
    , cur_trans_num(0)
  {
    cout << "============================================================================" << endl;
    cout << "Catapult TLM2 Model: mnist_mlp_tlm2_wrapper" << endl;
    cout << "      Instance name: " << name() << endl;
    cout << "   Catapult version: 10.4b/841621 Production Release" << endl;
    cout << "       Generated by: giuseppe@fastml02" << endl;
    cout << "     Generated date: Wed Dec 04 22:20:20 EST 2019" << endl;
    cout << "----------------------------------------------------------------------------" << endl;
    const char *test_verbosity = getenv("TEST_VERBOSITY");
    if (test_verbosity) {
      cout << "     TEST_VERBOSITY: " << test_verbosity << endl;
      string tv(test_verbosity);
      if (tv.compare("UVM_LOW")==0)    debug=1;
      if (tv.compare("UVM_MEDIUM")==0) debug=2;
      if (tv.compare("UVM_HIGH")==0)   debug=3;
      if (tv.compare("UVM_FULL")==0)   debug=4;
    }
    data_input1_ready_mode = AT_LEAST_ONE_CALLBACK;

    // Trigger this method any time inputs are changed
    SC_METHOD(execute_function);
    sensitive << doExecFunction;
    dont_initialize();

    // Register callback functions to be executed each time a generic payload transaction is set to each target socket
    input1_rsc_target.register_nb_transport_fw(this,&mnist_mlp_tlm2_wrapper::input1_rsc_nb_transport_fw);
  }

private: // Target socket response callbacks
  // Non-Blocking transport forward
  virtual tlm_sync_enum input1_rsc_nb_transport_fw(tlm_generic_payload &gp, tlm_phase &ph, sc_time &t)
  {
    tlm::tlm_command   cmd = gp.get_command();
    //sc_dt::uint64      adr = gp.get_address() / 4;
    //unsigned char *    ptr = gp.get_data_ptr();
    unsigned int       len = gp.get_data_length();
    unsigned char *    byt = gp.get_byte_enable_ptr();
    unsigned int       wid = gp.get_streaming_width();
    if (debug>2) {
      std::ostringstream msg;
      msg << "Generic Payload for RTL resource 'input1_rsc' in: " << gp << std::endl;
      SC_REPORT_INFO(this->name(),msg.str().c_str());
    }
    // Cases not supported
    if (byt != 0) { gp.set_response_status(tlm::TLM_BYTE_ENABLE_ERROR_RESPONSE); }
    if (wid < len) { gp.set_response_status(tlm::TLM_BURST_ERROR_RESPONSE); }
    // Reassemble function parameter(s)
    if (cmd == tlm::TLM_WRITE_COMMAND) {
      // FAPI_VARS='SIF_NAME input1 AVAILABLE {} CTYPE {ac_fixed<18, 8, true, AC_TRN, AC_WRAP > [784]} IS_CHANNEL 0 WIDTH 18 SIZE 784 DATAMODE IN DIMENSIONS {18 784} INDEX_1 14111 INDEX_2 0 ADDR_1 0 ADDR_2 0 ACCESS_EXPR {#v[#0]} VALUE_ACCESS_EXPR {#v[#0]}'
      // locate local member var for formal arg, call conversion reading slice from RTL and pasting via ACCESS_EXPR
      // vardata=SIF_NAME input1 AVAILABLE {} CTYPE {ac_fixed<18, 8, true, AC_TRN, AC_WRAP > [784]} IS_CHANNEL 0 WIDTH 18 SIZE 784 DATAMODE IN DIMENSIONS {18 784} INDEX_1 14111 INDEX_2 0 ADDR_1 0 ADDR_2 0 ACCESS_EXPR {#v[#0]} VALUE_ACCESS_EXPR {#v[#0]}
      // fmldata=FORMAL input1 fLV_LEN 0 CTYPE {ac_fixed<18, 8, true, AC_TRN, AC_WRAP > [784]} AVAILABLE 0 DATAMODE IN IS_CHANNEL 0 VALUE_CDECL {ac_fixed<18, 8, true, AC_TRN, AC_WRAP > #v[784]} isPtr 1 isRef 0 SCIpath /SCOPED_C_INTERFACE/GLOBAL_SCOPE/SCOPES/0/FORMALS/0 DIMENSIONS {0 {VALUE 784 type int}} LOC_INFO e9c1b2cb-d879-404d-a921-b773214bab78-657
      for (int idx_input1_0 = 0; idx_input1_0 < 784; ++idx_input1_0)
        gp_to_type(gp,18,0+18*idx_input1_0,&data_input1[idx_input1_0]);
      data_input1_callback_count++;
      // Now notify the execute_function
      doExecFunction.notify();
    } else {
      // TLM_READ_COMMAND - NYI
    }
    // Must ALWAYS return TLM_COMPLETED
    return TLM_COMPLETED;
  }

  void ClearInputCallbackCounts() {
    data_input1_callback_count = 0;
  }

  // Check conditions for calling C++ function
  bool OK_to_execute() {
    // Check to make sure sufficient data is available to be able to call the C++ function
    if (debug>1) {
      cout << "============================================================================" << endl;
      cout << "Catapult TLM2 Model: mnist_mlp_tlm2_wrapper" << endl;
      cout << "      Instance name: " << name() << endl;
      cout << "Current transaction: " << cur_trans_num << " @ " << sc_time_stamp() << endl;
    }
    bool is_OK_input1 = true;
    switch (data_input1_ready_mode) {
      case NON_EMPTY_CHAN: {
        assert(0); // Non-channel I/O
        break;
      }
      case CHAN_AVAIL: {
        assert(0); // Non-channel I/O
        break;
      }
      case AT_LEAST_ONE_CALLBACK: {
        if (data_input1_callback_count==0) {
          is_OK_input1 = false;
          if (debug>2) { cout << "    Input 'input1' not ready: callback_count is zero" << endl; }
        }
        break;
      }
      case EVERY_TRANS: {
        assert(0); // Not yet implemented
        break;
      }
      default:
      case DONT_CARE: {
        break;
      }
    }
    bool is_OK = (
        is_OK_input1
    );
    if (debug>1) {
      if (is_OK) { cout << "  Model can execute: YES" << endl; } else { cout << "  Model can execute: NO" << endl; }
      cout << "============================================================================" << endl;
    }
    return is_OK;
  }

  void execute_function() {
    // This is the main "execute" function. It is called by all target port callback functions.
    // It checks for necessary conditions and then formats the input data back into the
    // original function signature and calls the function

    if (!OK_to_execute()) return;

    // Call the C++ function
    cur_trans_num++;
    if (debug>1)
      SC_REPORT_INFO(this->name(),"execute_function() about to call C++ design");
    mnist_mlp(
       data_input1
      ,data_output1
      ,data_const_size_in_1
      ,data_const_size_out_1
    );
    ClearInputCallbackCounts();
    process_outputs();
  }

  void process_outputs() {
    if (debug>2)
      SC_REPORT_INFO(this->name(),"process_outputs()");
    // blkname=output1_rsc VARS='output1:e9c1b2cb-d879-404d-a921-b773214bab78-658:output1:e9c1b2cb-d879-404d-a921-b773214bab78-658'
    {
      tlm_generic_payload *gp = new tlm_generic_payload;
      sc_time delay = sc_time(1, SC_NS);
      gp->set_command(tlm::TLM_WRITE_COMMAND);
      gp->set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
      gp->set_address(0);
      ccs_allocate_gp(180,gp);
      for (int idx_output1_0 = 0; idx_output1_0 < 10; ++idx_output1_0)
        type_to_gp(data_output1[idx_output1_0],18,0+18*idx_output1_0,gp);
      if (debug>2) {
        std::ostringstream msg;
        msg << "Generic Payload for 'output1_rsc' out: " << *gp << std::endl;
        SC_REPORT_INFO(this->name(),msg.str().c_str());
      }
      tlm_phase phase;
      output1_rsc_initiator->nb_transport_fw(*gp,phase,delay);
      delete gp->get_data_ptr(); // free memory allocated by FN
    }
    // blkname=const_size_in_1_rsc VARS='const_size_in_1:e9c1b2cb-d879-404d-a921-b773214bab78-659:const_size_in_1:e9c1b2cb-d879-404d-a921-b773214bab78-659'
    {
      tlm_generic_payload *gp = new tlm_generic_payload;
      sc_time delay = sc_time(1, SC_NS);
      gp->set_command(tlm::TLM_WRITE_COMMAND);
      gp->set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
      gp->set_address(0);
      ccs_allocate_gp(16,gp);
      type_to_gp(data_const_size_in_1,16,0,gp);
      if (debug>2) {
        std::ostringstream msg;
        msg << "Generic Payload for 'const_size_in_1_rsc' out: " << *gp << std::endl;
        SC_REPORT_INFO(this->name(),msg.str().c_str());
      }
      tlm_phase phase;
      const_size_in_1_rsc_initiator->nb_transport_fw(*gp,phase,delay);
      delete gp->get_data_ptr(); // free memory allocated by FN
    }
    // blkname=const_size_out_1_rsc VARS='const_size_out_1:e9c1b2cb-d879-404d-a921-b773214bab78-660:const_size_out_1:e9c1b2cb-d879-404d-a921-b773214bab78-660'
    {
      tlm_generic_payload *gp = new tlm_generic_payload;
      sc_time delay = sc_time(1, SC_NS);
      gp->set_command(tlm::TLM_WRITE_COMMAND);
      gp->set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
      gp->set_address(0);
      ccs_allocate_gp(16,gp);
      type_to_gp(data_const_size_out_1,16,0,gp);
      if (debug>2) {
        std::ostringstream msg;
        msg << "Generic Payload for 'const_size_out_1_rsc' out: " << *gp << std::endl;
        SC_REPORT_INFO(this->name(),msg.str().c_str());
      }
      tlm_phase phase;
      const_size_out_1_rsc_initiator->nb_transport_fw(*gp,phase,delay);
      delete gp->get_data_ptr(); // free memory allocated by FN
    }
  }

private: // data
  sc_event doExecFunction;
  unsigned int debug;
  int cur_trans_num;

  // Inputs (formal args to function that are read-only)
  TargetReadyMode       data_input1_ready_mode;
  unsigned int          data_input1_callback_count;
  unsigned int          data_input1_next_transaction_number;
  ac_fixed<18, 8, true, AC_TRN, AC_WRAP > data_input1[784]; // input1 IN ac_fixed<18, 8, true, AC_TRN, AC_WRAP > #v[784] /SCOPED_C_INTERFACE/GLOBAL_SCOPE/SCOPES/0/FORMALS/0

  // Outputs (formal args to function that are write-only)
  ac_fixed<18, 8, true, AC_TRN, AC_WRAP > data_output1[10]; // output1 OUT ac_fixed<18, 8, true, AC_TRN, AC_WRAP > #v[10] /SCOPED_C_INTERFACE/GLOBAL_SCOPE/SCOPES/0/FORMALS/1
  unsigned short data_const_size_in_1               ; // const_size_in_1 OUT unsigned short #v /SCOPED_C_INTERFACE/GLOBAL_SCOPE/SCOPES/0/FORMALS/2
  unsigned short data_const_size_out_1              ; // const_size_out_1 OUT unsigned short #v /SCOPED_C_INTERFACE/GLOBAL_SCOPE/SCOPES/0/FORMALS/3
};
